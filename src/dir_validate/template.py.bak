""" Class used to load, verify, and save directory templates.
"""
# Future
from __future__ import annotations

# STL
import os
import enum
import functools
from operator import getitem
from collections import namedtuple
from typing import NamedTuple

# YAML
import yaml

""" Enumeration of supported Match types. """
class Match(enum.Enum):
    EXTENSION: 1
    EXACT: 2

""" A Node in the tree - this defines all the attributes we consider for validation. """
class Node(NamedTuple):
    name : str
    optional : bool
    hidden : bool
    extension : str
    match : Match
    parent : Node
    children : Sequence[Node]

    def dump(self) -> (str, dict):
        """ Return representation as a dictionary. """
        return (name, dict(self))

    @staticmethod
    def load(key : str, value : dict) -> Node:
        """ Factory Function to load from dictionary representation. """
        return Node(name=key, **value)

""" A Tree representation of a directory structure. """
class Tree:
    ...


""" Encapsulation of a directory template; loaded via file or string.
"""
class Template:
    # keywords
    FILE_KEY = "$FILES$"

    def __init__(self, stream):
        """ Construct a Template from the supplied string stream.

        Validation is done in-place and errors are thrown for invalid syntax and formatting.
        """
        # pass off complexity to yaml safe_load
        self.template_ = yaml.safe_load(stream)

        # @TODO validate

    def validate(self, dirname : str, allow_others : bool = True, skip_hidden : bool = True):
        """ Validate the given directory against our loaded template.

        Returns True if the given directory is valid, else False.

        Args:
            dirname:      Directory to validate.
            allow_others: Don't treat the presence of other files as an error.
            skip_hidden:  Ignore hidden files and directories (UNIX path convention)
        """
        # sanity checks
        assert (self.template_), "Template must be loaded before validation!"

        # iterate through the directory, checking for errors against our template
        for root, dirs, files in os.walk(dirname):
            # bypass hidden files and directories
            if skip_hidden:
                files = [f for f in files if not f[0] == '.']
                dirs[:] = [d for d in dirs if not d[0] == '.']

            # remove top level root directory and get list of sub-directories
            roots = root.replace(dirname, "", 1).split(os.sep)[1:]

            # get corresponding node in our template
            #  note - this should be ok, because we're proceeding hierarchically
            handle = functools.reduce(getitem, roots, self.template_)
            
            # check directories
            for directory in dirs:
                import pdb;pdb.set_trace()

        # if we made it this far we succeeded
        return True

    @classmethod
    def generate(cls, dirname : str, output : str, strict : bool = False, skip_hidden : bool = True):
        """ Helper function to generate a template file from an existing directory.

        This is intended for use as a first-pass autogeneration from an existing
        desired directory structure. The user can then edit certain hard-to-infer
        details like how to validate the files in each sub-directory.

        Args:
            dirname:     Directory to use as a template.
            output:      Filename to save the template.
            strict:      Whether or not to require exact files - default behavior just validates by extension.
            skip_hidden: Ignore hidden files and directories (UNIX path convention)
        """
        # set up helper function to add files to desired level of strictness
        def get_files_strict(files):
            return files
        def get_files(files):
            extensions = set()
            for filename in files:
                split = filename.split(os.extsep,1)
                if len(split) == 2:
                    extensions.add(f"*.{split[-1]}")
                else:
                    extensions.add(f"*.")
            return extensions

        # initialize as a dictionary
        template = {}

        # walk through all directories / files
        for root, dirs, files in os.walk(dirname):
            # bypass hidden files and directories
            if skip_hidden:
                files = [f for f in files if not f[0] == '.']
                dirs[:] = [d for d in dirs if not d[0] == '.']

            # remove top level root directory and get list of sub-directories
            roots = root.replace(dirname, "", 1).split(os.sep)[1:]

            # get target node in our dictionary
            if roots == [""]:
                # handle first root (empty):
                handle = template
            else:
                # otherwise, access the proper place
                handle = functools.reduce(getitem, roots, template)
            
            # naively add directories to their place in the hierarchy
            for directory in dirs:
                handle[directory] = {}

            # add files based on our desired level of strictness
            filenames = get_files_strict(files) if strict else get_files(files)
            if len(filenames) != 0:
                handle[cls.FILE_KEY] = []
                for filename in filenames:
                    handle[cls.FILE_KEY].append(filename)

        # done; write to file
        with open(output, "w") as yamlfile:
            yaml.dump(template, yamlfile)
        print(f"Wrote extracted template from '{dirname}' to '{output}'")
    
